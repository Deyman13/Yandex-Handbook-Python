"""
Шашки

Шашки очень занимательная игра, которую достаточно легко моделировать.

Правила подразумевают наличие двух классов: игральная доска и шашка. Однако мы немного упростим себе задачу и вместо 
шашки будем манипулировать клетками, которые могут находиться в трех состояниях: пустая, белая шашка и чёрная шашка.

Разработайте два класса: Checkers и Cell.

Объекты класса Checkers при инициализации строят игральную доску со стандартным распределением клеток и должны обладать
методами:

move(f, t) — перемещает шашку из позиции f в позицию t;
get_cell(p) — возвращает объект «клетка» в позиции p.
Объекты класса Cell при инициализации принимают одно из трех состояний: W — белая шашка, B — чёрная шашка, * — пустая 
клетка, а также обладают методом status() возвращающим заложенное в ней состояние.

Координаты клеток описываются строками вида PQ, где:

P — столбец игральной доски, одна из заглавных латинских букв: ABCDEFGH;
Q — строка игральной доски, одна из цифр: 12345678.
Будем считать, что пользователь всегда ходит правильно и контролировать возможность хода не требуется.

Примечание
Ваше решение должно содержать только классы и функции.
В решении не должно быть вызовов инициализации требуемых классов.

Ввод:
checkers = Checkers()
for row in '87654321':
    for col in 'ABCDEFGH':
        print(checkers.get_cell(col + row).status(), end='')
    print()

Вывод:
XBXBXBXB
BXBXBXBX
XBXBXBXB
XXXXXXXX
XXXXXXXX
WXWXWXWX
XWXWXWXW
WXWXWXWX

Ввод:
checkers = Checkers()
checkers.move('C3', 'D4')
checkers.move('H6', 'G5')
for row in '87654321':
    for col in 'ABCDEFGH':
        print(checkers.get_cell(col + row).status(), end='')
    print()

Вывод:
XBXBXBXB
BXBXBXBX
XBXBXBXX
XXXXXXBX
XXXWXXXX
WXXXWXWX
XWXWXWXW
WXWXWXWX
"""

class Checkers:
    def __init__(self):
        # Словарь для итерации по ключам и значениям (Например: A1: X, B1: B, C1: X, D1: B)
        # При этом неважно в каком порядке будут поступать строки и столбцы, что крайне важно. 
        self.board = {}
        # Итерация по строкам от 1 до 8 включительно 
        for row in range(1, 9):
            # Итерация по столбцам так же от 1 до 8 включительно, поле 8 на 8
            for col in 'ABCDEFGH':
                # Придание нужного вида: A1, B1, C1
                coordinates = col + str(row)
                # Условие, которое определяет выставление символа. 
                # Я использую тут ord() для выявления разницы между символами A и BCDEFGH
                # Т.е. A = 65, B = 66, C = 67 и т.д. 
                # Тем самым, если столбец четный - поставится символ X
                if (row + ord(col) - ord('A')) % 2 == 0:
                    self.board[coordinates] = Cell('X')
                # Если строка меньше или равна 3 по условиям задачи, выставляем W
                elif row <= 3:
                    self.board[coordinates] = Cell('W')
                # Так как 2 в центре не учитываем, то сразу после 6 строки включительно выставляем B
                elif row >= 6:
                    self.board[coordinates] = Cell('B')
                # Иначе X (т.е. заполняем центр символами X)
                else:
                    self.board[coordinates] = Cell('X')

    def move(self, f, t):
        # Меняем местами символы. Место X - символ. Место символа X
        self.board[t] = self.board[f]
        self.board[f] = Cell('X')

    def get_cell(self, p):
        # Возвращаем значение клетки, т.е. символ X, B или W
        return self.board[p]

class Cell:
    def __init__(self, status):
        # Инициализируем статус, в который передается символ
        self._status = status

    def status(self):
        # Возвращаем данный символ
        return self._status
