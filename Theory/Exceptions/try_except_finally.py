"""
При выполнении заданий к главам вы скорее всего нередко сталкивались с возникновением различных ошибок. 
На этой главе мы изучим подход, который позволяет обрабатывать ошибки после их возникновения.

Напишем программу, которая будет считать обратные значения для целых чисел из заданного диапазона и 
выводить их в одну строку с разделителем ";". Один из вариантов кода для решения этой задачи выглядит так:
"""

print(";".join(str(1 / x) for x in range(int(input()), int(input()) + 1)))

# 1 10
# 1.0;0.5;0.3333333333333333;0.25;0.2;0.16666666666666666;0.14285714285714285;0.125;0.1111111111111111;0.1

"""
Программа получилась в одну строчку за счёт использования списочных выражений. 
Однако при вводе диапазона чисел, включающем в себя 0 (например, от -1 до 1), программа выдаст следующую ошибку:

    ZeroDivisionError: division by zero

В программе произошла ошибка "деление на ноль". Такая ошибка, возникающая при выполнении программы и 
останавливающая её работу, называется исключением.

Попробуем в нашей программе избавиться от возникновения исключения деления на ноль. 
Пусть при попадании 0 в диапазон чисел, обработка не производится и выводится сообщение 
"Диапазон чисел содержит 0". Для этого нужно проверить до списочного выражения наличие нуля в диапазоне:
"""

interval = range(int(input()), int(input()) + 1)
if 0 in interval:
    print("Диапазон чисел содержит 0.")
else:
    print(";".join(str(1 / x) for x in interval))

# -1 1 
# Диапазон чисел содержит 0.

"""
Теперь для диапазона, включающего в себя 0, например, от -2 до 2, исключения ZeroDivisionError не возникнет. 
Однако при вводе строки, которую невозможно преобразовать в целое число (например, "a"), будет вызвано другое 
исключение:

ValueError: invalid literal for int() with base 10: 'a'

Произошло исключение ValueError. Для борьбы с этой ошибкой нам придётся проверить, что строка состоит только из цифр.
Сделать это нужно до преобразования в число. Тогда наша программа будет выглядеть так:
"""

start = input()
end = input()
# Метод lstrip("-"), удаляющий символы "-" в начале строки, нужен для учёта
# отрицательных чисел, иначе isdigit() вернёт для них False
if not (start.lstrip("-").isdigit() and end.lstrip("-").isdigit()):
    print("Необходимо ввести два числа.")
else:
    interval = range(int(start), int(end) + 1)
    if 0 in interval:
        print("Диапазон чисел содержит 0.")
    else:
        print(";".join(str(1 / x) for x in interval))

"""
еперь наша программа работает без ошибок и при вводе строк, которые нельзя преобразовать в целое число.

Подход, который был нами применён для предотвращения ошибок, называется "Look Before You Leap" (LBYL), или 
"посмотри перед прыжком". В программе, реализующей такой подход, проверяются возможные условия возникновения 
ошибок до исполнения основного кода.

Подход LBYL имеет недостатки. Программу из примера стало сложнее читать из-за вложенного условного оператора. 
Проверка условия, что строка может быть преобразована в число, выглядит даже сложнее, чем списочное выражение. 
Вложенный условный оператор не решает поставленную задачу, а только лишь проверяет входные данные на корректность. 
Легко заметить, что решение основной задачи заняло меньше времени, чем составление условий проверки корректности 
входных данных.

Существует другой подход для работы с ошибками: "Easier to Ask Forgiveness than Permission" (EAFP) или 
"проще извиниться, чем спрашивать разрешение". В этом подходе сначала исполняется код, а в случае возникновения 
ошибок происходит их обработка. Подход EAFP реализован в Python в виде обработки исключений.

Исключения в Python являются классами ошибок. В Python есть много стандартных исключений. 
Они имеют определённую иерархию за счёт механизма наследования классов. В документации Python версии 3.10.8 
приводится следующее дерево иерархии стандартных исключений:


BaseException
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- GeneratorExit
 +-- Exception
      +-- StopIteration
      +-- StopAsyncIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      |    +-- ModuleNotFoundError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      |    +-- RecursionError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- EncodingWarning
           +-- ResourceWarning

Для обработки исключения в Python используется следующий синтаксис:

try:
    <код , который может вызвать исключения при выполнении>
except <классисключения_1>:
    <код обработки исключения>
except <классисключения_2>:
    <код обработки исключения>
...
else:
    <код выполняется, если не вызвано исключение в блоке try>
finally:
    <код , который выполняется всегда>

Блок try содержит код, в котором нужно обработать исключения, если они возникнут. 
При возникновении исключения интерпретатор последовательно проверяет в каком из блоков except обрабатывается 
это исключение. Исключение обрабатывается в первом блоке except, обрабатывающем класс этого исключения или 
базовый класс возникшего исключения. Необходимо учитывать иерархию исключений для определения порядка их 
обработки в блоках except. Начинать обработку исключений следует с более узких классов исключений. 
Если начать с более широкого класса исключения, например, Exception, то всегда при возникновении исключения 
будет срабатывать первый блок except. Сравните два следующих примера. В первом порядок обработки исключений 
указан от производных классов к базовым, а во втором – наоборот.
"""

try:
    print(1 / int(input()))
except ZeroDivisionError:
    print("Ошибка деления на ноль.")
except ValueError:
    print("Невозможно преобразовать строку в число.")
except Exception:
    print("Неизвестная ошибка.")

"""
При вводе значений "0" и "a" получим ожидаемый соответствующий возникающим исключениям вывод:

Невозможно преобразовать строку в число.

и

Ошибка деления на ноль.

Второй пример:


try:
    print(1 / int(input()))
except Exception:
    print("Неизвестная ошибка.")
except ZeroDivisionError:
    print("Ошибка деления на ноль.")
except ValueError:
    print("Невозможно преобразовать строку в число.")

При вводе значений "0" и "a" получим в обоих случаях неинформативный вывод:

Неизвестная ошибка.

Необязательный блок else выполняет код в случае, если в блоке try не вызвано исключение. 
Добавим блок else в пример для вывода сообщения об успешном выполнении операции:
"""

try:
    print(1 / int(input()))
except ZeroDivisionError:
    print("Ошибка деления на ноль.")
except ValueError:
    print("Невозможно преобразовать строку в число.")
except Exception:
    print("Неизвестная ошибка.")
else:
    print("Операция выполнена успешно.")

"""
Теперь при вводе корректного значения, например, "5", вывод программы будет следующим:

2.0
Операция выполнена успешно.

Блок finally выполняется всегда, даже если возникло какое-то исключение, не учтённое в блоках except 
или код в этих блоках сам вызвал какое-либо исключение. Добавим в нашу программу вывод строки 
"Программа завершена" в конце программы даже при возникновении исключений:
"""

try:
    print(1 / int(input()))
except ZeroDivisionError:
    print("Ошибка деления на ноль.")
except ValueError:
    print("Невозможно преобразовать строку в число.")
except Exception:
    print("Неизвестная ошибка.")
else:
    print("Операция выполнена успешно.")
finally:
    print("Программа завершена.")

"""
Перепишем код, созданный с применением подхода LBYL, для первого примера из этой главы 
с использованием обработки исключений:
"""

try:
    print(";".join(str(1 / x) for x in range(int(input()), int(input()) + 1)))
except ZeroDivisionError:
    print("Диапазон чисел содержит 0.")
except ValueError:
    print("Необходимо ввести два числа.")

"""
Теперь наша программа читается намного легче. 
При этом создание кода для обработки исключений не заняло много времени и не потребовало проверки сложных условий.

Исключения можно принудительно вызывать с помощью оператора raise. Этот оператор имеет следующий синтаксис:

    raise <класс исключения>(параметры)

В качестве параметра можно, например, передать строку с сообщением об ошибке.

В Python можно создавать свои собственные исключения. Синтаксис создания исключения такой же, как и 
у создания класса. При создании исключения его необходимо наследовать от какого-либо стандартного класса-исключения.

Напишем программу, которая выводит сумму списка целых чисел, и вызывает исключение, если в списке чисел есть 
хотя бы одно чётное или отрицательное число. Создадим свои классы исключений:

NumbersError – базовый класс исключения;
EvenError – исключение, которое вызывается при наличии хотя бы одного чётного числа;
NegativeError – исключение, которое вызывается при наличии хотя бы одного отрицательного числа.
"""

class NumbersError(Exception):
    pass


class EvenError(NumbersError):
    pass


class NegativeError(NumbersError):
    pass


def no_even(numbers):
    if all(x % 2 != 0 for x in numbers):
        return True
    raise EvenError("В списке не должно быть чётных чисел")


def no_negative(numbers):
    if all(x >= 0 for x in numbers):
        return True
    raise NegativeError("В списке не должно быть отрицательных чисел")


def main():
    print("Введите числа в одну строку через пробел:")
    try:
        numbers = [int(x) for x in input().split()]
        if no_negative(numbers) and no_even(numbers):
            print(f"Сумма чисел равна: {sum(numbers)}.")
    except NumbersError as e:  # обращение к исключению как к объекту
        print(f"Произошла ошибка: {e}.")
    except Exception as e:
        print(f"Произошла непредвиденная ошибка: {e}.")

        
if __name__ == "__main__":
    main()


"""
Обратите внимание: в программе основной код выделен в функцию main. 
А код вне функций содержит только условный оператор и вызов функции main при выполнении 
условия __name__ == "__main__". Это условие проверяет, запущен ли файл как самостоятельная 
программа или импортирован как модуль.

Любая программа, написанная на языке программирования Python может быть импортирована как 
модуль в другую программу. В идеологии Python импортировать модуль – значит полностью его выполнить. 
Если основной код модуля содержит вызовы функций, ввод или вывод данных без использования указанного 
условия __name__ == "__main__", то произойдёт полноценный запуск программы. 
А это не всегда удобно, если из модуля нужна только отдельная функция или какой-либо класс.

При изучении модуля itertools, мы говорили о том, как импортировать модуль в программу. 
Покажем ещё раз два способа импорта на примере собственного модуля.

Для импорта модуля из файла, например example_module.py, нужно указать его имя, если он находится 
в той же папке, что и импортирующая его программа:

    import example_module

Если требуется отдельный компонент модуля, например функция или класс, то импорт можно осуществить так:

    from example_module import some_function, ExampleClass

Обратите внимание: при втором способе импортированные объекты попадают в пространство имён новой программы. 
Это означает, что они будут объектами новой программы, и в программе не должно быть других объектов с 
такими же именами.
"""


